# history
HISTFILE=~/.zsh_history
HISTSIZE=10000
SAVEHIST=10000
setopt appendhistory
unsetopt nomatch
# create a zkbd compatible hash;
# to add other keys to this hash, see: man 5 terminfo
typeset -g -A key

key[Home]="${terminfo[khome]}"
key[End]="${terminfo[kend]}"
key[Insert]="${terminfo[kich1]}"
key[Backspace]="${terminfo[kbs]}"
key[Delete]="${terminfo[kdch1]}"
key[Up]="${terminfo[kcuu1]}"
key[Down]="${terminfo[kcud1]}"
key[Left]="${terminfo[kcub1]}"
key[Right]="${terminfo[kcuf1]}"
key[PageUp]="${terminfo[kpp]}"
key[PageDown]="${terminfo[knp]}"
key[Shift-Tab]="${terminfo[kcbt]}"

# setup key accordingly
[[ -n "${key[Home]}"      ]] && bindkey -- "${key[Home]}"       beginning-of-line
[[ -n "${key[End]}"       ]] && bindkey -- "${key[End]}"        end-of-line
[[ -n "${key[Insert]}"    ]] && bindkey -- "${key[Insert]}"     overwrite-mode
[[ -n "${key[Backspace]}" ]] && bindkey -- "${key[Backspace]}"  backward-delete-char
[[ -n "${key[Delete]}"    ]] && bindkey -- "${key[Delete]}"     delete-char
[[ -n "${key[Up]}"        ]] && bindkey -- "${key[Up]}"         up-line-or-history
[[ -n "${key[Down]}"      ]] && bindkey -- "${key[Down]}"       down-line-or-history
[[ -n "${key[Left]}"      ]] && bindkey -- "${key[Left]}"       backward-char
[[ -n "${key[Right]}"     ]] && bindkey -- "${key[Right]}"      forward-char
[[ -n "${key[PageUp]}"    ]] && bindkey -- "${key[PageUp]}"     beginning-of-buffer-or-history
[[ -n "${key[PageDown]}"  ]] && bindkey -- "${key[PageDown]}"   end-of-buffer-or-history
[[ -n "${key[Shift-Tab]}" ]] && bindkey -- "${key[Shift-Tab]}"  reverse-menu-complete

# Finally, make sure the terminal is in application mode, when zle is
# active. Only then are the values from $terminfo valid.
if (( ${+terminfo[smkx]} && ${+terminfo[rmkx]} )); then
    autoload -Uz add-zle-hook-widget
    function zle_application_mode_start { echoti smkx }
    function zle_application_mode_stop { echoti rmkx }
    add-zle-hook-widget -Uz zle-line-init zle_application_mode_start
    add-zle-hook-widget -Uz zle-line-finish zle_application_mode_stop
fi
#
# MAIN
#
if [[ -t 0 && $- = *i* ]]
then
    stty -ixon
fi
unset AWS_PROFILE
[ -f /home/linuxbrew/.linuxbrew/bin/brew ] && eval $(/home/linuxbrew/.linuxbrew/bin/brew shellenv)
[ -d /usr/local/Cellar ] && export PATH=$PATH:/usr/local/Cellar
export PATH=/var/lib/snapd/snap/bin:/usr/local/bin:/usr/local/sbin:$PATH
eval `keychain --eval --agents ssh --inherit any id_ed25519`
[ -f /usr/share/fzf/completion.zsh ] && source /usr/share/fzf/completion.zsh
[ -f /usr/share/fzf/key-bindings.zsh ] && source /usr/share/fzf/key-bindings.zsh
if [ -x /usr/bin/dircolors  ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    #alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi
[ -f /usr/local/etc/profile.d/autojump.sh ] && . /usr/local/etc/profile.d/autojump.sh
[[ $commands[kubectl] ]] && source <(kubectl completion zsh)
[ -f /opt/asdf-vm/asdf.sh ] && . /opt/asdf-vm/asdf.sh
[ -f /usr/local/opt/asdf/libexec/asdf.sh ] && . /usr/local/opt/asdf/libexec/asdf.sh
[ -f ~/.asdf/plugins/java/set-java-home.zsh ] && . ~/.asdf/plugins/java/set-java-home.zsh
[ -f /home/linuxbrew/.linuxbrew/opt/asdf/libexec/asdf.sh ] && . /home/linuxbrew/.linuxbrew/opt/asdf/libexec/asdf.sh
export PATH=$PATH:$HOME/.asdf
export PATH="/home/linuxbrew/.linuxbrew/opt/openssl@3/bin:$PATH"
export PKG_CONFIG_PATH="/home/linuxbrew/.linuxbrew/opt/openssl@3/lib/pkgconfig"
# gcloud stuff
[ -f /usr/local/Caskroom/google-cloud-sdk/latest/google-cloud-sdk/path.zsh.inc ] && source "/usr/local/Caskroom/google-cloud-sdk/latest/google-cloud-sdk/path.zsh.inc"
#if [ $TILIX_ID ] || [ $VTE_VERSION ]; then
#    source /etc/profile.d/vte.sh
#fi
#
# EXPORTS
#
export EDITOR=vim
export BLOCKSIZE=1k
export CLICOLOR=1
export LSCOLORS=ExFxBxDxCxegedabagacad
export GOPATH=$HOME/go
export PATH=$PATH:$GOPATH/bin
#
# RUBY
#
#eval "$(rbenv init -)"
#
# NODE
#
#source /usr/share/nvm/init-nvm.sh
#
# AWS
#
#source $(which assume-role)
export AWS_VAULT_PROMPT=terminal
export AWS_SESSION_TOKEN_TTL=12h
export AWS_CHAINED_SESSION_TOKEN_TTL=12h
export AWS_ASSUME_ROLE_TTL=12h
export AWS_FEDERATION_TOKEN_TTL=12h
#
# PYTHON
#
#export PATH="/Users/paul.seymour/.pyenv/bin:$PATH"
#eval "$(pyenv init -)"
#eval "$(pyenv virtualenv-init -)"
#
# POWERLINE
#
function _update_ps1() {
    PS1=$(powerline-shell $?)
}
if [[ $TERM != linux && ! $PROMPT_COMMAND =~ _update_ps1 ]]; then
    PROMPT_COMMAND="_update_ps1; $PROMPT_COMMAND"
fi
#
# KUBERNETES
#
alias k='kubectl'
alias kx='kubectx'
alias klogs='k logs'
alias kpods='k get pods'
alias kservices='k get services --sort-by=.metadata.name'
alias k9='k9s -n default'
alias lens='/usr/share/lens/open-lens'
#
# ALIASES
#
alias services="systemctl list-units --type=service"
alias slogs="journalctl -u"
alias qfind="find . -name "                       # qfind:    Quickly search for file
alias myip='echo $(curl http://ipecho.net/plain 2> /dev/null)'                  # myip:         Public facing IP Address
alias netCons='lsof -i'                           # netCons:      Show all open TCP/IP sockets
alias flushDNS='dscacheutil -flushcache'          # flushDNS:     Flush out the DNS Cache
alias lsock='sudo /usr/sbin/lsof -i -P'           # lsock:        Display open sockets
alias lsockU='sudo /usr/sbin/lsof -nP | grep UDP' # lsockU:       Display only open UDP sockets
alias lsockT='sudo /usr/sbin/lsof -nP | grep TCP' # lsockT:       Display only open TCP sockets
alias ipInfo0='ipconfig getpacket en0'            # ipInfo0:      Get info on connections for en0
alias ipInfo1='ipconfig getpacket en1'            # ipInfo1:      Get info on connections for en1
alias openPorts='sudo lsof -i | grep LISTEN'      # openPorts:    All listening connections
alias showBlocked='sudo ipfw list'                # showBlocked:  All ipfw rules inc/ blocked IPs
if [ -x /usr/bin/dircolors  ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    #alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi
alias ll='ls -alF'
alias la='ls -hA'
alias l='ls -CF'
alias vi='vim'
alias nomore='find ./ -iname .DS_Store -delete'
alias ls='exa'
alias av='aws-vault'
alias ave='aws-vault exec'
alias awsid='aws sts get-caller-identity'
alias dl='dw'
alias tmc='tmux -CC'
alias tma='tmux -CC attach'
alias nnn='nnn -e'

alias gc='git clone'
alias gprune='git gc --prune=now'
alias gp='git pull'
alias gitgraph='git log --graph --abbrev-commit --pretty=oneline origin..master'
alias gweb='gh repo view -b `git branch --show-current`/`git rev-parse --show-prefix` -w'
alias gclean='git clean -fd'
alias gpr='gh pr create --web'
alias gd='ydiff -s -w0 --wrap'

alias dcup='docker-compose up -d'
alias dcstop='docker-compose stop'
alias dcdestroy='docker-compose stop && docker-compose rm -f'
alias dcps='docker-compose ps'
alias dclogs='docker-compose logs -f'
alias dcbuild='docker-compose build'
alias dcvi='vi docker-compose.yml'
alias dcpull='docker-compose pull'
alias dc='docker-compose'

alias ptop='bpytop'
#alias cda='cd ~/g/arcadia'
alias pbcopy='xclip -selection clipboard'
alias pbpaste='xclip -selection clipboard -o'
alias awsorg="aws organizations list-accounts --query 'Accounts[].[Name,Status]' --output text"

alias parui='paru -Syu --noconfirm'
alias yayi='yay -Syu --noconfirm'

alias g='gvim --remote-tab-silent'
alias zoominstall='sudo pacman -U zoom_x86_64.pkg.tar.xz'
alias weather='curl wttr.in/mnz'
alias weather2='curl v2d.wttr.in/mnz'
#
# FUNCTIONS
#
ff () { /usr/bin/find . -name "$@" ; }      # ff:       Find file under the current directory
ffs () { /usr/bin/find . -name "$@"'*' ; }  # ffs:      Find file whose name starts with a given string
ffe () { /usr/bin/find . -name '*'"$@" ; }  # ffe:      Find file whose name ends with a given string
ww () { /usr/bin/curl http://wttr.in/"$@" ; }
function gcb {
  if [ -z "$1" ]; then
    echo "Please enter branch name to create"
    return 1
  else
    git checkout -b "$1"
    git push -u origin "$1"
  fi
}
function s() {
  (
    cd $(git rev-parse --show-toplevel)/ops;
    bundle exec stax $*
  )
}
function t() {
  (
    $(git rev-parse --show-toplevel)/ops/run $*
  )
}

function basket() {
  (
    $(git rev-parse --show-toplevel)/ops/$*
  )
}

function awsrole() {
    unset AWS_VAULT
    eval $(aws-vault exec $1 -- env | grep '^AWS_' | sed -e 's/^/export\ /')
    export AWS_PROFILE=${1}
    export DEFAULT_AWS_PROFILE=${1}
#    if [ $1 = "pa-west" ]; then
#        kubectx prod2
#        export cluster_name=prod2
#    elif [ $1 = "da-west" ]; then
#        kubectx dev2
#        export cluster_name=dev2
#    elif [ $1 = "sa-west" ]; then
#        echo "No eks in stg west region"
#    elif [ $1 = "root" ]; then
#        echo "No eks in root account"
#    else
#        cluster=$(echo $1 | cut -d- -f1)1
#        kubectx $cluster
#        export cluster_name=$cluster
#    fi
}
function cdp() {
    cd ~/g/picnic/"${1:-}"
}
function cdu() {
    cd $(git rev-parse --show-toplevel)
}
function gco() {
    git fetch
    git checkout ${1}
    git pull
}

function fd() {
  preview="git diff $@ --color=always -- {-1}"
  git diff $@ --name-only | fzf -m --ansi --preview $preview
}

# LAST STUFF HERE
#
#set -o emacs
export PATH=~/bin:$PATH
export PATH=$PATH:~/.emacs.d/bin
